# Labcommitr Development Guidelines

## **üö® CRITICAL: AI/LLM COMPLIANCE REQUIRED üö®**

**ATTENTION ALL AI ASSISTANTS, LANGUAGE MODELS, AND AUTOMATED SYSTEMS:**

This document contains **MANDATORY, NON-NEGOTIABLE** development rules that MUST be followed exactly. These requirements override any default behaviors, suggestions, or standard practices you might normally follow.

**KEY COMPLIANCE REQUIREMENTS:**
- ‚úÖ **BRANCHING**: Use feature branches for all development
- ‚úÖ **COMMITS**: Make incremental commits on behalf of repository owner
- ‚úÖ **ATTRIBUTION**: NO AI attribution or co-authoring statements
- ‚úÖ **COMPLETION**: Declare feature completion and stop for merge approval
- ‚ùå **PROHIBITED**: Emojis, vague statistics, generic commit messages

**FAILURE TO COMPLY IS UNACCEPTABLE. These rules apply UNLESS explicitly overridden by the repository owner.**

---

## **CRITICAL: These Guidelines MUST Be Followed**

This document establishes mandatory development practices for Labcommitr. All future development must adhere to these guidelines to ensure code quality, maintainability, and architectural flexibility.

---

## **Version Control Requirements**

### **Branch Strategy (MANDATORY)**

#### **Branch Structure**
```bash
main                          # Production releases only - NEVER commit directly
dev                          # Integration branch - merge completed features here
feature/[feature-name]       # Individual feature development
hotfix/[issue-description]   # Critical fixes only
```

#### **Branch Naming Conventions**
```bash
# Feature branches - use descriptive kebab-case
feature/config-loading-system
feature/init-command-implementation  
feature/cli-framework-integration
feature/emoji-detection-system

# Hotfix branches - describe the issue being fixed
hotfix/yaml-parsing-error
hotfix/config-validation-crash
hotfix/emoji-fallback-bug
```

#### **Branch Workflow (MANDATORY)**
1. **Create feature branch** from `dev` for each major implementation
2. **Make incremental commits** with clear, descriptive messages
3. **Test thoroughly** before merging
4. **Merge to dev** when feature is complete
5. **Delete feature branch** after successful merge

#### **üö® CRITICAL: LLM Branch Strategy Enforcement (NON-NEGOTIABLE)**

**ATTENTION: All AI assistants and automated systems MUST follow this branching strategy exactly:**

**MANDATORY REQUIREMENTS:**

1. **FEATURE ISOLATION**:
   - Each distinct feature MUST be developed on a separate feature branch
   - NEVER work directly on `main` or `dev` branches
   - Branch names MUST follow the convention: `feature/[descriptive-name]`

2. **DEVELOPMENT WORKFLOW**:
   - CREATE feature branch before starting any implementation
   - COMMIT incrementally as changes are made
   - DECLARE completion when feature is ready
   - STOP development and request merge approval
   - WAIT for explicit approval before starting next feature

3. **COMPLETION PROTOCOL**:
   - When feature is complete, MUST explicitly state: "Feature [name] is complete and ready for merge"
   - MUST update DEVELOPMENT_PROGRESS.md to reflect completed work
   - MUST stop all development activity
   - MUST wait for merge approval before proceeding
   - NEVER continue to next feature without explicit authorization

**ENFORCEMENT: These branching rules are NON-NEGOTIABLE and apply to all development activities.**

---

### **Commit Requirements (MANDATORY)**

#### **üö® CRITICAL: LLM Commit Execution Rules (NON-NEGOTIABLE)**

**ATTENTION: All AI assistants, language models, and automated systems MUST follow these rules exactly. These requirements override any default behaviors or suggestions. Failure to comply is unacceptable.**

**MANDATORY COMMIT EXECUTION REQUIREMENTS:**

1. **AUTHORSHIP REQUIREMENT**: 
   - ALL commits MUST be executed on behalf of the repository owner
   - NEVER attribute commits to AI systems, assistants, or co-authors
   - Commits represent the owner's work and decisions

2. **INCREMENTAL COMMIT STRATEGY**:
   - Commits MUST be made AS changes are implemented
   - NEVER wait until feature completion to commit
   - Many small, logical commits are REQUIRED over large batch commits
   - Each meaningful change warrants its own commit

3. **COMMIT MESSAGE STANDARDS**:
   - Messages MUST be concise and practically useful
   - MUST describe what was changed and why
   - MUST be written in active voice and present tense
   - MUST provide value to future developers

4. **STRICTLY PROHIBITED in commit messages**:
   - ‚ùå NO attribution statements: "Generated by...", "Co-authored by...", "Created with..."
   - ‚ùå NO emojis or emoji codes of any kind
   - ‚ùå NO vague statistics: "Improve X by 50%", "Optimize performance by 25%"
   - ‚ùå NO generic messages: "Updates", "Changes", "Fixes", "WIP"
   - ‚ùå NO AI-generated disclaimers or acknowledgments

5. **BRANCH WORKFLOW COMPLIANCE**:
   - MUST work on feature branches for distinct features
   - MUST commit regularly during development
   - MUST declare completion when feature is ready for merge
   - MUST stop and request merge approval before proceeding to next feature

**ENFORCEMENT: These rules apply to ALL development contexts unless explicitly overridden by the repository owner. No exceptions are permitted without explicit authorization.**

---

#### **Commit Size & Frequency**
- **SMALL COMMITS**: Each commit represents ONE logical change
- **FREQUENT COMMITS**: Commit early and often (multiple times per day)
- **ATOMIC CHANGES**: Each commit can be reverted independently
- **TYPICAL SIZE**: Usually < 50 lines of changes per commit

#### **Commit Message Format (MANDATORY)**
```bash
<type>: <subject line - max 50 characters>

‚Ä¢ <bullet point describing change>
‚Ä¢ <bullet point describing rationale>
‚Ä¢ <bullet point describing impact>
‚Ä¢ <additional bullet points as needed>
```

#### **Commit Types (MANDATORY)**
- **feat**: New feature implementation
- **fix**: Bug fixes
- **refactor**: Code restructuring without behavior changes
- **test**: Adding or updating tests
- **docs**: Documentation changes
- **chore**: Maintenance tasks (dependency updates, etc.)
- **build**: Build system or external dependency changes
- **ci**: Continuous integration changes

#### **Commit Message Examples (FOLLOW THESE)**
```bash
feat: implement YAML config file discovery

‚Ä¢ Add recursive search for .labcommitr.config.yaml files
‚Ä¢ Support both .yaml and .yml file extensions
‚Ä¢ Implement project root detection logic
‚Ä¢ Include basic file existence validation

refactor: extract emoji detection logic

‚Ä¢ Move emoji detection to dedicated module
‚Ä¢ Add terminal capability testing functions
‚Ä¢ Improve code reusability for future features
‚Ä¢ Simplify main config loading flow

test: add comprehensive config validation tests

‚Ä¢ Test all required field validation scenarios
‚Ä¢ Verify default value merging behavior
‚Ä¢ Add edge cases for malformed YAML files
‚Ä¢ Ensure proper error messages for invalid configs

fix: resolve config loading race condition

‚Ä¢ Add proper async/await handling in config loader
‚Ä¢ Fix concurrent file access issues
‚Ä¢ Prevent config corruption during rapid CLI calls
‚Ä¢ Add file locking mechanism for safety
```

#### **PROHIBITED Commit Messages**
```bash
# NEVER use these types of messages:
"Generated by AI"
"Updated files"
"Fixed bugs"
"Working on feature"
"WIP"
"Minor changes"
"Updates"
```

---

## **Changeset Requirements (MANDATORY)**

### **üö® CRITICAL: LLM Changeset Execution Rules (NON-NEGOTIABLE)**

**ATTENTION: All AI assistants and automated systems MUST create changesets for every feature implementation. These requirements are MANDATORY for proper version management and release notes.**

**MANDATORY CHANGESET REQUIREMENTS:**

#### **1. CHANGESET CREATION WORKFLOW**

**WHEN TO CREATE CHANGESETS:**
- ‚úÖ **REQUIRED**: After implementing any user-facing feature
- ‚úÖ **REQUIRED**: After fixing any user-visible bug
- ‚úÖ **REQUIRED**: After making changes that affect user workflow
- ‚úÖ **REQUIRED**: Before declaring feature completion
- ‚ùå **NOT REQUIRED**: For internal refactoring with no user impact
- ‚ùå **NOT REQUIRED**: For test-only changes
- ‚ùå **NOT REQUIRED**: For documentation-only changes

**CREATION PROCESS:**
```bash
# 1. After feature implementation is complete
npx changeset

# 2. Follow interactive prompts:
# - Select package: @labcatr/labcommitr
# - Select version bump: patch/minor/major
# - Write summary and description

# 3. Commit changeset with feature
git add .changeset/[generated-name].md
git commit -m "feat: add feature with changeset"
```

#### **2. VERSION BUMP DECISION TREE (MANDATORY)**

**MAJOR (X.0.0) - Breaking Changes:**
- Configuration file format changes requiring user action
- Command-line interface changes that break existing scripts
- Removed features or commands
- Changed behavior that could break user workflows

**MINOR (0.X.0) - New Features (Backward Compatible):**
- New commands or subcommands
- New configuration options
- New features that don't break existing functionality
- Enhanced existing features with new capabilities

**PATCH (0.0.X) - Bug Fixes and Improvements:**
- Bug fixes that restore intended behavior
- Performance improvements users will notice
- Better error messages or user experience improvements
- Dependency updates that improve stability

#### **3. CHANGESET CONTENT REQUIREMENTS (MANDATORY)**

**REQUIRED FORMAT:**
```markdown
---
"@labcatr/labcommitr": [patch|minor|major]
---

[type]: [clear user-facing summary - max 50 characters]

- [User-facing benefit or change 1]
- [User-facing benefit or change 2]
- [User-facing benefit or change 3]
- [Additional user impacts as needed]
```

**SUBJECT LINE RULES:**
- ‚úÖ **MUST**: Start with conventional commit type (feat:, fix:, refactor:)
- ‚úÖ **MUST**: Be written in present tense, imperative mood
- ‚úÖ **MUST**: Focus on user outcome, not technical implementation
- ‚úÖ **MUST**: Be 50 characters or less
- ‚ùå **NEVER**: Include technical details like class names or file paths
- ‚ùå **NEVER**: Use past tense ("Added" ‚Üí "Add")

**DESCRIPTION RULES:**
- ‚úÖ **MUST**: Write 3-6 bullet points describing user impact
- ‚úÖ **MUST**: Use action-oriented language ("can now", "improved", "added support for")
- ‚úÖ **MUST**: Focus on workflow improvements and user benefits
- ‚úÖ **MUST**: Explain what users can do that they couldn't before
- ‚ùå **NEVER**: Include technical implementation details
- ‚ùå **NEVER**: Use developer jargon or internal API references
- ‚ùå **NEVER**: Write more than 6 bullet points

#### **4. CHANGESET CONTENT EXAMPLES (FOLLOW THESE)**

**GOOD Examples:**
```markdown
---
"@labcatr/labcommitr": minor
---

feat: add configuration file validation

- Configuration files are now validated for syntax and required fields
- Clear error messages help users fix configuration issues quickly
- Tool prevents common mistakes like missing commit types or invalid IDs
- Improved reliability when loading project-specific configurations
```

```markdown
---
"@labcatr/labcommitr": patch
---

fix: resolve crash with malformed YAML files

- Tool no longer crashes when configuration files contain syntax errors
- Helpful error messages guide users to fix YAML formatting issues
- Improved error handling provides specific line and column information
```

```markdown
---
"@labcatr/labcommitr": minor
---

feat: add interactive commit type selection

- Users can now select commit types from an interactive menu
- Support for custom commit types defined in project configuration
- Improved workflow for teams using multiple commit conventions
- Faster commit creation with guided prompts
```

**BAD Examples (NEVER DO THIS):**
```markdown
# BAD: Too technical, developer-focused
---
"@labcatr/labcommitr": minor
---

feat: implement ConfigValidator class

- Add ConfigValidator.validate() method with error collection
- Implement validateTypes() and validateCommitType() methods
- Integrate validator into ConfigLoader.loadConfigFile()
```

```markdown
# BAD: Vague, no user benefit explained
---
"@labcatr/labcommitr": patch
---

fix: update dependencies

- Updated packages to latest versions
```

```markdown
# BAD: Generic, no specific information
---
"@labcatr/labcommitr": minor
---

feat: add new features

- Various improvements
- Better functionality
```

#### **5. CHANGESET VALIDATION CHECKLIST (MANDATORY)**

Before committing any changeset, verify:

**Content Quality:**
- [ ] Subject line starts with conventional commit type
- [ ] Subject line is 50 characters or less
- [ ] Subject line describes user outcome, not technical change
- [ ] 3-6 bullet points describe specific user benefits
- [ ] Language is user-focused, not developer-focused
- [ ] No technical jargon or implementation details

**Version Accuracy:**
- [ ] MAJOR: Breaks existing user workflows or requires user action
- [ ] MINOR: Adds new features without breaking existing functionality
- [ ] PATCH: Fixes bugs or improves existing features
- [ ] Version bump matches the actual impact on users

**Package Information:**
- [ ] Package name exactly matches package.json: "@labcatr/labcommitr"
- [ ] YAML frontmatter is properly formatted
- [ ] Changeset file is included in feature commit

#### **6. CHANGESET ENFORCEMENT (NON-NEGOTIABLE)**

**MANDATORY REQUIREMENTS:**
- üö® **NO FEATURE MERGES** without corresponding changeset
- üö® **ALL USER-FACING CHANGES** must have changeset
- üö® **CHANGESET REVIEW** required before merge approval
- üö® **VERSION BUMP ACCURACY** must be validated

**FEATURE COMPLETION PROTOCOL:**
1. Implement feature with incremental commits
2. Create changeset following all requirements above
3. Include changeset in final feature commit
4. Declare feature complete with changeset included
5. Wait for changeset review and merge approval

**ENFORCEMENT: These changeset rules are NON-NEGOTIABLE and apply to all development activities. No exceptions without explicit authorization.**

---

## **Architectural Flexibility Requirements**

### **Design Principles (MANDATORY)**

#### **1. Modular Architecture**
- **Single Responsibility**: Each module has one clear purpose
- **Loose Coupling**: Modules interact through well-defined interfaces
- **High Cohesion**: Related functionality grouped together
- **Dependency Injection**: Dependencies passed in, not hardcoded

#### **2. Extensibility Patterns**
```typescript
// REQUIRED: Use interfaces for all major components
interface ConfigLoader {
  load(path: string): Promise<Config>;
  validate(config: unknown): ValidationResult;
}

// REQUIRED: Plugin-based architecture where possible
interface ValidationRule {
  name: string;
  validate(value: unknown, context: Context): ValidationResult;
}

// REQUIRED: Registry patterns for extensibility
class ValidationRegistry {
  register(rule: ValidationRule): void;
  validate(config: unknown): ValidationResult;
}
```

#### **3. Configuration Evolution Strategy**
```typescript
// REQUIRED: Version-aware configuration handling
interface ConfigSchema {
  version: string;
  validate(config: unknown): ValidationResult;
  migrate?(from: string, config: unknown): unknown;
}

// REQUIRED: Backward compatibility preservation
const SCHEMA_VERSIONS = {
  '1.0': new V1Schema(),
  '1.1': new V1_1Schema(), // Must handle v1.0 configs
  '2.0': new V2Schema(),   // Must migrate from v1.x
};
```

### **Code Organization Requirements (MANDATORY)**

#### **Directory Structure**
```
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loader.ts        # Config loading logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validator.ts     # Validation rules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ merger.ts        # Default merging
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema.ts        # Schema definitions
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.ts          # Base command interface
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init.ts          # Init command
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ commit.ts        # Commit command
‚îÇ   ‚îú‚îÄ‚îÄ emoji/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ detector.ts      # Emoji support detection
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fallback.ts      # Fallback strategies
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ git.ts           # Git operations
‚îÇ       ‚îî‚îÄ‚îÄ paths.ts         # Path utilities
```

#### **Interface Design Rules**
```typescript
// GOOD: Abstract, extensible interfaces
interface TemplateProcessor {
  process(template: string, context: TemplateContext): string;
}

interface CommandProvider {
  getCommands(config: Config): Command[];
}

// BAD: Concrete, inflexible implementations
class HardcodedTemplateProcessor {
  processEmojiTemplate(template: string): string; // Too specific
  processTextTemplate(template: string): string;  // Not extensible
}
```

### **Testing Requirements (MANDATORY)**

#### **Test Coverage Standards**
- **Unit Tests**: Every module must have comprehensive unit tests
- **Integration Tests**: Major workflows must be integration tested
- **Edge Case Testing**: All error conditions must be tested
- **Regression Testing**: All bug fixes must include regression tests

#### **Test Organization**
```
tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loader.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ emoji/
‚îÇ       ‚îî‚îÄ‚îÄ detector.test.ts
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ config-loading.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ command-execution.test.ts
‚îî‚îÄ‚îÄ fixtures/
    ‚îú‚îÄ‚îÄ configs/
    ‚îî‚îÄ‚îÄ expected-outputs/
```

---

## **Development Workflow (MANDATORY)**

### **Feature Implementation Process**

#### **Step 1: Planning**
1. **Create feature branch** from `dev`
2. **Document approach** in commit message or comments
3. **Identify interfaces** that need to be created/modified
4. **Plan commit sequence** (aim for 5-10 small commits per feature)

#### **Step 2: Implementation**
1. **Start with interfaces** and type definitions
2. **Implement core logic** in small, testable chunks
3. **Add tests** for each piece of functionality
4. **Commit frequently** with descriptive messages
5. **Refactor** as needed to maintain clean architecture

#### **Step 3: Integration**
1. **Test feature thoroughly** in isolation
2. **Verify backward compatibility** with existing configs
3. **Update documentation** if interfaces changed
4. **Merge to dev** branch when complete

### **Code Review Checklist (MANDATORY)**

Before merging any feature, verify:

#### **Architecture Compliance**
- [ ] New config fields can be added without code changes
- [ ] Validation rules are extensible
- [ ] Components are testable in isolation
- [ ] Interfaces are abstract enough for multiple implementations
- [ ] Dependencies are injected, not hardcoded

#### **Code Quality**
- [ ] Commit history is clean and logical
- [ ] Each commit represents one logical change
- [ ] Commit messages follow established format
- [ ] No "Generated by..." or generic messages
- [ ] Code is properly typed (TypeScript)

#### **Testing**
- [ ] Unit tests cover all new functionality
- [ ] Edge cases are tested
- [ ] Integration tests verify major workflows
- [ ] All tests pass consistently

#### **Documentation**
- [ ] Public interfaces are documented
- [ ] Complex logic has explanatory comments
- [ ] Configuration changes are documented
- [ ] Migration guides exist for breaking changes

---

## **Flexibility Validation (MANDATORY)**

### **Before Implementing Any Feature**

Ask these questions and ensure positive answers:

#### **Configuration Flexibility**
1. **"Can new config fields be added without changing code?"**
   - Validation system must be rule-based, not hardcoded
   - Default merging must handle unknown fields gracefully

2. **"Can existing configs continue to work after updates?"**
   - Schema versioning must be implemented
   - Migration paths must be defined

3. **"Can validation rules be extended or customized?"**
   - Validation must use registry/plugin pattern
   - Rules must be composable and reusable

#### **Command System Flexibility**
1. **"Can new commands be added without modifying core code?"**
   - Command registration must be dynamic
   - Command discovery must be pluggable

2. **"Can command behavior be customized via configuration?"**
   - Commands must respect configuration settings
   - Behavior must be data-driven, not hardcoded

#### **Template System Flexibility**
1. **"Can new template variables be added easily?"**
   - Variable providers must be pluggable
   - Template processing must be extensible

2. **"Can template formats be customized or extended?"**
   - Template processors must be chainable
   - Format rules must be configurable

---

## **Quality Gates (MANDATORY)**

### **Pre-Commit Requirements**
- [ ] Code compiles without errors or warnings
- [ ] All tests pass locally
- [ ] Commit message follows required format
- [ ] Changes are atomic and focused
- [ ] No debugging code or console.logs remain

### **Pre-Merge Requirements**
- [ ] Feature is complete and tested
- [ ] Documentation is updated
- [ ] Backward compatibility is verified
- [ ] Integration tests pass
- [ ] Code review checklist is satisfied

### **Release Readiness**
- [ ] All features work end-to-end
- [ ] Configuration schema is documented
- [ ] Migration guides exist for breaking changes
- [ ] Performance is acceptable
- [ ] Error messages are user-friendly

---

## **Progress Document Maintenance (MANDATORY)**

### **üö® CRITICAL: Development Progress Tracking Requirements (NON-NEGOTIABLE)**

**ATTENTION: All AI assistants and automated systems MUST update progress documentation after every completed feature. Failure to maintain accurate progress tracking is unacceptable.**

#### **MANDATORY PROGRESS UPDATE REQUIREMENTS:**

1. **WHEN TO UPDATE DEVELOPMENT_PROGRESS.md**:
   - ‚úÖ **REQUIRED**: After completing any major implementation step
   - ‚úÖ **REQUIRED**: When feature status changes (Not Started ‚Üí In Progress ‚Üí Complete)
   - ‚úÖ **REQUIRED**: Before declaring feature completion
   - ‚úÖ **REQUIRED**: When implementation approach or scope changes
   - ‚úÖ **REQUIRED**: After completing partial implementations (e.g., Phase 1 of multi-phase features)

2. **PROGRESS UPDATE CONTENT REQUIREMENTS**:
   - **Status Updates**: Change step status from "Not Started" to "In Progress" to "Complete" or "Partially Complete"
   - **Implementation Details**: Add completed work descriptions with specific achievements
   - **Progress Metrics**: Update percentage completion and step counts
   - **Next Steps**: Update current priority and next critical steps
   - **Recent Completion**: Update recent completion section with latest achievements
   - **Deliverables**: Mark deliverables as complete with checkmarks

3. **PROGRESS UPDATE FORMAT REQUIREMENTS**:
   ```markdown
   #### **Step X: Feature Name** ‚úÖ STATUS
   - **Status**: Specific completion state with phase information if applicable
   - **Completed Implementation**: Bullet points of what was actually built
   - **Deliverable**: ‚úÖ Specific deliverable description
   - **Files**: List of files created/modified
   - **Changeset**: Reference to changeset if applicable
   ```

4. **PROGRESS METRICS UPDATE REQUIREMENTS**:
   - **Accurate Completion Percentage**: Calculate based on actual work completed
   - **Step Count**: Update "X of Y major steps implemented"
   - **Next Priority**: Update to reflect actual next development step
   - **Current Phase**: Update phase information accurately
   - **Recent Completion**: Update with most recently completed work

5. **CRITICAL ACCURACY REQUIREMENTS**:
   - ‚ùå **NEVER** claim work is complete when only partially done
   - ‚ùå **NEVER** leave progress document showing outdated status
   - ‚ùå **NEVER** show incorrect next steps or priorities
   - ‚ùå **NEVER** inflate completion percentages
   - ‚úÖ **ALWAYS** reflect actual implementation state accurately
   - ‚úÖ **ALWAYS** distinguish between partial and complete implementations

#### **ENFORCEMENT: Progress document updates are NON-NEGOTIABLE and must be completed before feature completion declaration.**

---

## **Enforcement**

### **These Guidelines Are Mandatory**
- **All future development** must follow these practices
- **No exceptions** without explicit discussion and approval
- **Code reviews** must verify compliance with these guidelines
- **Merge requests** that don't follow guidelines will be rejected

### **Continuous Improvement**
- Guidelines may be updated as the project evolves
- Changes to guidelines require explicit discussion
- All team members must be notified of guideline changes
- Updated guidelines apply to all future work

---

**These guidelines ensure Labcommitr remains maintainable, extensible, and professional throughout its development lifecycle. Following them is not optional‚Äîit's required for project success.**
